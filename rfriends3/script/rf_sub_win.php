<?php
 function rfmenu_config_win() { global $cfgdir; global $rf_stp; global $ttl_no; global $ttl_mes; echo_msg(2, "毎日自動で行う処理の設定を行います。"); echo_msg(2, ""); $mnu = array("登録","取消"); $msel = rf_sel_menu($mnu,1); if ($msel < 0) { return; } $ttl_no[0] = 3; $ttl_no[3] = $msel; $ttl_mes[3] = $mnu[$msel-1]; if ($msel == 1) { rfmenu_subtitle("デイリー処理(radiko,radiru,timefree)を登録します。"); echo_msg(2, "登録すると毎日自動で予約処理(radiko,radiru)と録音(timefree)を行います。"); echo_msg(2, ""); $ans = echo_yesno(2, "実行しますか? (y/N): "); if ($ans == "y" || $ans == "Y") { rfgw_config_sch_reg(); rf_pause(); } } if ($msel == 2) { rfmenu_subtitle("デイリー処理の登録を取り消します。"); $ans = echo_yesno(2, "実行しますか? (y/N): "); if ($ans == "y" || $ans == "Y") { rfgw_config_sch_can(); rf_pause(); } } } function get_schdata_cnt($head, $ex_type) { global $rsvdir; $schdata_cnt = 0; $ret = querysch($head); foreach ($ret as $val) { $dat = explode(",", $val, 3); if ($dat[1] != "\"N/A\"") { $sch0 = str_replace($head, "", $dat[0]); $sch = str_replace("\"", "", $sch0); $fn_dat = $rsvdir.$sch.".dat"; if (file_exists($fn_dat)) { $schdata_cnt++; } else { at_delete($dat[0]); } } } return $schdata_cnt; } function get_schdata_cnt_simple() { global $schradiko_head; global $schradiru_head; $cmd = "schtasks /query /fo csv /nh | find /V \"N/A\""; $ret = external_exec($cmd); $schdata_cnt = 0; foreach ($ret as $val) { if (strpos($val, $schradiko_head) !== false) { $schdata_cnt++; } } $rcnt[0] = $schdata_cnt; $schdata_cnt = 0; foreach ($ret as $val) { if (strpos($val, $schradiru_head) !== false) { $schdata_cnt++; } } $rcnt[1] = $schdata_cnt; return $rcnt; } function get_schdata($head, $ex_type, $typ) { global $rsvdir; $n = 0; $schdata = array(); $ret = querysch($head); foreach ($ret as $val) { $dat = explode(",", $val, 3); if ($dat[1] != "\"N/A\"") { $sch0 = str_replace($head, "", $dat[0]); $sch = str_replace("\"", "", $sch0); $fn_dat = $rsvdir.$sch.".dat"; if (file_exists($fn_dat)) { $wdata = file($fn_dat); $wdata0 = $wdata[0]; $para = get_para($wdata0, $ex_type); $para[12] = $dat[0]; $wdata0 = put_para($para, $ex_type); $schdata[] = $wdata0; $n++; } else { echo_msg(2, "file not found $fn_dat"); at_delete($dat[0]); echo_msg(2, ""); } } } return $schdata; } function sch_reg($fn, $tn, $sc, $st) { global $scrdir; global $tmpdir; global $phpdir; $ws = "wscript.exe"; $vb = $scrdir."invisible.vbs"; $ex = $scrdir.$fn; $tr = "$ws //nologo $vb $ex"; $taskreg = "SCHTASKS /create /tn $tn /tr \"$tr\" /sc $sc /st $st"; external_sys("$taskreg > nul"); $fn = make_fn("exrecord"); $xml = $tmpdir.$fn."_1.xml"; $xmlmod = $tmpdir.$fn."_2.xml"; $taskquery = "schtasks /query /tn $tn /XML"; external_sys("$taskquery > $xml"); sch_mod($xml, $xmlmod); $taskdel = "schtasks /delete /tn $tn /f"; external_sys("$taskdel > nul"); $taskmod = "schtasks /create /tn $tn /XML $xmlmod"; external_sys("$taskmod > nul"); unlink($xml); unlink($xmlmod); } function cleanupsch($sch_name) { $ret = querysch($sch_name); $n = 0; foreach ($ret as $val) { $dat = explode(",", $val, 3); if ($dat[1] == "\"N/A\"") { $n++; $taskdel = "SCHTASKS /Delete /TN $dat[0] /f"; external_sys($taskdel); } } return $n; } function at_reserve_win($tn, $sttime, $fnm, $bs) { global $scrdir; global $base; global $wake_to_run; global $tmpdir; $msg_level = 1; $fn = make_fn("friends_at_reserve"); $xmlorg = $tmpdir.$fn."_1.xml"; $xmlmod = $tmpdir.$fn."_2.xml"; $sd = date("Y/m/d", $sttime); $st = date("H:i:s", $sttime); $vb = "$scrdir"."invisible.vbs"; $tr = "'wscript.exe' //nologo '$vb' '$bs'"; $taskcre = "SCHTASKS /Create /SC ONCE /F /SD $sd /ST $st /TN $tn /TR \"$tr\""; $taskdel = "SCHTASKS /Delete /TN $tn /f"; $taskmod = "SCHTASKS /Create /TN $tn /XML $xmlmod"; $taskqry = "SCHTASKS /query /TN $tn /XML > $xmlorg"; $pathphp = $base . "bin\\php\\"; $wakerun = $pathphp . "php $scrdir"."rfriends_schmod.php $xmlorg > $xmlmod"; if ($msg_level > 0) { $taskcre .= " > nul"; $taskdel .= " > nul"; $taskmod .= " > nul"; } echo_msg(0, $taskcre); $ret = external_sys($taskcre); if ($wake_to_run == 1) { $ret = external_sys($taskqry); sch_mod($xmlorg, $xmlmod); $ret = external_sys($taskdel); $ret = external_sys($taskmod); unlink($xmlorg); unlink($xmlmod); } if ($ret != 0) { $ret = 5; } return $ret; } function rf_ffmpeg_pid_win($mode) { $pid_data1 = rf_ffmpeg_pid_ffmpeg_win(); if ($mode != 1) { return $pid_data1; } $pid_data2 = rf_ffmpeg_pid_dontsleep_win($pid_data1); if (count_73($pid_data1) < 1) { return $pid_data2; } if (count_73($pid_data2) < 1) { return $pid_data1; } $pid_data = array_merge($pid_data1,$pid_data2); return $pid_data; } function rf_ffmpeg_pid_dontsleep_win($pid_data1) { global $pid_ex_win_sleep; global $ex_radiko; global $ex_radiru; $pid_data = array(); $ex = $pid_ex_win_sleep; exec($ex, $data, $ret); if ($ret != 0) { return $pid_data; } foreach($data as $dat) { $dat = preg_replace('/\s+/', ' ', trim($dat)); $p = explode(" ",$dat); if (count_73($p) < 4) continue; $pp = explode(",",$p[3]); if (count_73($pp) != 5) continue; $ex_type = $pp[0]; if ($ex_type != $ex_radiko && $ex_type != $ex_radiru) continue; $fn = $pp[1]; $ret = false; foreach($pid_data1 as $pid) { $ret = strpos($pid,$fn); if ($ret !== false) break; } if ($ret !== false) continue; $ppp = explode("_",$fn); if (count_73($ppp) < 3) continue; $st = $ppp[0].$ppp[1]; $pid_data[] = "0,encoder=\"standby\",$st,$fn"; } return $pid_data; } function rf_ffmpeg_pid_ffmpeg_win() { global $bindir; global $tmpdir; global $pid_ex_win; global $pid_dlm_win; global $pid_start_win; global $pid_cline_win; global $pid_pid_win; global $pid_cdate_win; $pid_data = array(); $ex = $pid_ex_win; $ffmpeg_path = $bindir."ffmpeg"; $dlm = $pid_dlm_win; $start_text = $pid_start_win; $cline_text = $pid_cline_win; $pid_text = $pid_pid_win; $cdate_text = $pid_cdate_win; exec($ex, $data, $ret); if ($ret != 0) { return $pid_data; } $data_n = count_73($data); if ($data_n < 2) { return $pid_data; } $cline_no = -1; $pid_no = -1; $cdate_no = -1; $dat_n = 0; for ($i=0; $i<2; $i++) { $val = $data[$i]; $val = preg_replace('/\s+/', ' ', trim($val)); $dat = explode($dlm, $val); if (count_73($dat) < 3) { continue; } if ($dat[0] != $start_text) { continue; } $n = array_search($cline_text, $dat); if ($n !== false) { $cline_no = $n; } $n = array_search($pid_text, $dat); if ($n !== false) { $pid_no = $n; } $n = array_search($cdate_text, $dat); if ($n !== false) { $cdate_no = $n; } $dat_n = count_73($dat); break; } if ($cline_no == -1 || $pid_no == -1 || $cdate_no == -1) { return $pid_data; } foreach ($data as $val) { $val = preg_replace('/\s+/', ' ', trim($val)); $dat = explode($dlm, $val); if (count_73($dat) < $dat_n) { continue; } $pid = $dat[$pid_no]; $cdate = substr($dat[$cdate_no], 0, 14); $cline = $dat[$cline_no]; $cline = preg_replace('/\s+/', ' ', trim($cline)); $para = explode(" ", $cline); if (count_73($para) < 2) { continue; } $ret = rf_val_search($para, $ffmpeg_path); if ($ret === false) { continue; } $ret = rf_val_search($para, $tmpdir); if ($ret === false) { continue; } $fil = $para[$ret]; $ret = rf_val_search($para, "encoder"); if ($ret === false) { $encoder = "unknown"; } else { $encoder = $para[$ret]; } $fmt = "$pid,$encoder,$cdate,$fil"; $pid_data[] = $fmt; } return $pid_data; } function rf_ps_win($dat) { global $bindir; global $tmpdir; global $pid_ex_win; global $pid_dlm_win; global $pid_start_win; global $pid_cline_win; global $pid_pid_win; global $pid_cdate_win; $pid_data = array(); $ex = $pid_ex_win; $dlm = $pid_dlm_win; $start_text = $pid_start_win; $cline_text = $pid_cline_win; $pid_text = $pid_pid_win; $cdate_text = $pid_cdate_win; exec($ex, $data, $ret); if ($ret != 0) { return false; } $data_n = count_73($data); if ($data_n < 2) { return false; } $cline_no = -1; $pid_no = -1; $cdate_no = -1; $dat_n = 0; for ($i=0; $i<2; $i++) { $val = $data[$i]; $val = preg_replace('/\s+/', ' ', trim($val)); $dat = explode($dlm, $val); if (count_73($dat) < 3) { continue; } if ($dat[0] != $start_text) { continue; } $n = array_search($cline_text, $dat); if ($n !== false) { $cline_no = $n; } $n = array_search($pid_text, $dat); if ($n !== false) { $pid_no = $n; } $n = array_search($cdate_text, $dat); if ($n !== false) { $cdate_no = $n; } $dat_n = count_73($dat); break; } if ($cline_no == -1 || $pid_no == -1 || $cdate_no == -1) { return false; } foreach ($data as $val) { if (strpos($val,$dat) !== false) { return $val; } } return false; } function rf_ffplay_pid_win() { global $bindir; global $tmpdir; global $pid_ex_win; global $pid_ex_win_p; global $pid_dlm_win; global $pid_start_win; global $pid_cline_win; global $pid_pid_win; global $pid_cdate_win; $pid_data = array(); $ex = $pid_ex_win_p; $ffplay_path = $bindir."ffplay"; $dlm = $pid_dlm_win; $start_text = $pid_start_win; $cline_text = $pid_cline_win; $pid_text = $pid_pid_win; $cdate_text = $pid_cdate_win; exec($ex, $data, $ret); if ($ret != 0) { return $pid_data; } $data_n = count_73($data); if ($data_n < 2) { return $pid_data; } $cline_no = -1; $pid_no = -1; $cdate_no = -1; $dat_n = 0; for ($i=0; $i<2; $i++) { $val = $data[$i]; $val = preg_replace('/\s+/', ' ', trim($val)); $dat = explode($dlm, $val); if (count_73($dat) < 3) { continue; } if ($dat[0] != $start_text) { continue; } $n = array_search($cline_text, $dat); if ($n !== false) { $cline_no = $n; } $n = array_search($pid_text, $dat); if ($n !== false) { $pid_no = $n; } $n = array_search($cdate_text, $dat); if ($n !== false) { $cdate_no = $n; } $dat_n = count_73($dat); break; } if ($cline_no == -1 || $pid_no == -1 || $cdate_no == -1) { return $pid_data; } foreach ($data as $val) { $val = preg_replace('/\s+/', ' ', trim($val)); $dat = explode($dlm, $val); if (count_73($dat) < $dat_n) { continue; } $pid = $dat[$pid_no]; $cdate = substr($dat[$cdate_no], 0, 14); $cline = $dat[$cline_no]; $cline = preg_replace('/\s+/', ' ', trim($cline)); $para = explode(" ", $cline); $n = count_73($para); if ($n < 2) { continue; } $ret = rf_val_search($para, $ffplay_path); if ($ret === false) { continue; } if (($p = strpos($val, "-window_title")) === false) { continue; } $val2 = substr($val,$p); if (($p = strpos($val2, "rfriends")) === false) { continue; } $val2 = substr($val2,$p); $val3 = explode(" ",$val2,2); $ch = str_replace("rfriends_","",$val3[0]); $fil = $para[$n-1]; $fmt = "$pid,$ch,$fil"; $pid_data[] = $fmt; } return $pid_data; } function rf_update_sub_tool_win($rpath, $tmpdir_rf, $upbtxt_fl, $ty) { global $usrdir; global $tmpdir; global $bindir; $ret = rf_update_get_tool($upbtxt_fl, $tmpdir, $ty); if ($ret === false) { echo_msg(2, "更新ファイルがありません。"); return(0); } if (file_exists($bindir."x86")) { echo_msg(2, "更新ファイルがありません。(x86)"); return(0); } $upbin_dat = trim(file_get_contents($tmpdir.$upbtxt_fl)); fin_unlink($tmpdir.$upbtxt_fl); $fl = $bindir.$upbin_dat; if (file_exists("$fl")) { echo_msg(2, "TOOLは最新です。"); return(0); } echo_msg(2, ""); echo_msg(2, "binバージョン : $upbin_dat"); echo_msg(2, ""); echo_msg(2, "ラジオ番組の録音中は行わないでください。"); echo_msg(2, ""); $ans = echo_yesno(2, "TOOL(Windows)を更新しますか? (y/N): "); if ($ans == "y" || $ans == "Y") { $ret = rfgw_update_bin($rpath, $ty); if ($ret == 0) { echo_msg(2, "更新成功"); } else { echo_msg(2, "更新失敗"); $fl = $bindir.$upbin_dat; fin_unlink($fl); } rf_update_fin_tool(); echo_msg(2, ""); echo_msg(2, "一旦終了します。"); return(1); } else { return(0); } } function at_delete($tn) { $cmd = "SCHTASKS /Delete /F /TN $tn"; external_sys($cmd); } function cleanupsch_all($sch_name) { $ret = querysch($sch_name); $n = 0; foreach ($ret as $val) { $dat = explode(",", $val, 3); $n++; $taskdel = "SCHTASKS /Delete /TN $dat[0] /f"; external_sys($taskdel); } return $n; } function querysch($sch_name) { $cmd = "schtasks /query /fo csv /nh | find \"$sch_name\""; $ret = external_exec($cmd); return $ret; } function dispsch($sch_name) { $ret = querysch($sch_name); foreach ($ret as $val) { echo_msg(0, $val); } $n = count_73($ret); return $n; } function sch_mod($xml, $xmlmod) { global $wake_to_run; global $sch_battery; $wake = "false"; $battery = "true"; if ($wake_to_run == 1) { $wake = "true"; } if ($sch_battery == 1) { $battery = "false"; } $fl = file($xml, FILE_IGNORE_NEW_LINES|FILE_SKIP_EMPTY_LINES); $settings = "<Settings>"; $WakeToRun = "<WakeToRun>"; $ifonbatteries = "<DisallowStartIfOnBatteries>"; $GoingOnBatteries = "<StopIfGoingOnBatteries>"; $fl2 = array(); foreach ($fl as $ln) { if (($n = strpos($ln, $WakeToRun)) !== false) { continue; } if (($n = strpos($ln, $ifonbatteries)) !== false) { continue; } if (($n = strpos($ln, $GoingOnBatteries)) !== false) { continue; } $fl2[] = $ln; } $dat = ""; foreach ($fl2 as $ln) { if (($n = strpos($ln, $settings)) === false) { $dat .= $ln.PHP_EOL; } else { $dat .= $ln.PHP_EOL; $dat .= "    <WakeToRun>$wake</WakeToRun>".PHP_EOL; $dat .= "    <DisallowStartIfOnBatteries>$battery</DisallowStartIfOnBatteries>".PHP_EOL; $dat .= "    <StopIfGoingOnBatteries>$battery</StopIfGoingOnBatteries>".PHP_EOL; } } file_put_contents($xmlmod, $dat, LOCK_EX); } function rf_play_text_win($fn, $flg) { global $editor_cui; global $editor_gui; global $snd_player; global $editor_cui_win; global $editor_gui_win; global $snd_player_win; if (!file_exists($fn)) { echo_msg(2, "file not found $fn"); return 1; } $flg = 0; if ($flg == 0) { $pl = $editor_gui_win; if ($pl == "") { $pl = $editor_gui; } rfgw_ret_extsys($pl, $fn); } else { $pl = $editor_cui_win; if ($pl == "") { $pl = $editor_cui; } echo_msg(2,"cui editor : $pl"); echo_msg(2, "Editor is not available in this mode."); } return 0; } function rf_play_snd_win($fn, $flg) { global $editor_cui; global $editor_gui; global $snd_player; global $editor_cui_win; global $editor_gui_win; global $snd_player_win; if (!file_exists($fn)) { echo_msg(2, "file not found $fn"); return 1; } if ($flg == 0) { $pl = $snd_player_win; if ($pl == "") { $pl = $snd_player; } rfgw_ret_extsys($pl, $fn); } else { echo_msg(2, "This file cannot be played in this mode."); } return 0; } 