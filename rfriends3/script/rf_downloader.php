<?php
 function rf_addimg($recfiletmp, $ext, $para) { $app = rfgw_addimg_app(); $fn = get_art_img($recfiletmp, $ext, $para); if ($fn == null) { echo_prn(1, "addtag_img error (image not found)"); return 0; } else { $ret = addtag_img($app, $recfiletmp, $ext, $fn); if ($ret != 0) { echo_prn(1, "addtag_img error ($app)"); } fin_unlink($fn); return 0; } } function rftrans_ex($ex_type, $fr, $ext, $to, $para) { global $rftrans; global $rftrans_s; global $rftrans_dir; global $rftrans_radiko; global $rftrans_radiru; global $rftrans_timefree; global $rftrans_radiru_vod; global $rftrans_radiru_gogaku; global $rftrans_podcast; global $rftrans_codec; global $rftrans_codec_opt; global $DS; global $tmpdir; global $prohibit_mp3; global $ex_radiko; global $ex_radiru; global $ex_timefree; global $ex_radiru_vod; global $ex_radiru_gogaku; global $ex_podcast; if ($rftrans == 0) { return true; } $cflg = 0; switch ($ex_type) { case $ex_radiko: $cflg = $rftrans_radiko; $head = "K_"; $sdir = "radiko"; break; case $ex_radiru: $cflg = $rftrans_radiru; $head = "R_"; $sdir = "radiru"; break; case $ex_timefree: $cflg = $rftrans_timefree; $head = "T_"; $sdir = "timefree"; break; case $ex_radiru_vod: $cflg = $rftrans_radiru_vod; $head = "V_"; $sdir = "radiru_vod"; break; case $ex_radiru_gogaku: $cflg = $rftrans_radiru_gogaku; $head = "G_"; $sdir = "radiru_gogaku"; break; case $ex_podcast: $cflg = $rftrans_podcast; $head = "P_"; $sdir = "podcast"; break; default: break; } if ($cflg == 0) { echo_prn(1, "trans : off"); return true; } echo_prn(1, ""); if ($rftrans == 1 || $rftrans == 2) { $idir = realpath($rftrans_dir); if ($idir === false) { echo_prn(1, "define error : $rftrans_dir"); return false ; } rf_mkdir($idir); if (!is_dir($idir)) { echo_prn(1, "not found : $rftrans_dir"); return false ; } } switch ($rftrans) { case 1: $out = $idir.$DS.$head.$to; break; case 2: if ($rftrans_s != 3) { $fdir = $idir.$DS.$sdir; $ret = rf_mkdir($fdir); if ($ret === false) { echo_prn(1,"mkdir error : $fdir"); return false; } if ($ex_type == $ex_podcast) { $ch = ";"; $title = fn_edit($para[18]); $ttldir = $title; } else { $ch = $para[6]; $title = fn_edit($para[7]); $ttldir = $ch."_".$title; } echo_prn(1,"fdir  : $fdir  idir :$idir  sdir : $sdir  ch : $ch  title : $title"); } switch ($rftrans_s) { case 1: $fdir = $fdir.$DS.$ttldir; break; case 2: if ($ch != ";") $fdir = $fdir.$DS.$ch; break; case 3: $fdir = $idir; break; case 0: default: if ($ch != ";") { $fdir = $fdir.$DS.$ch; rf_mkdir($fdir); } $fdir = $fdir.$DS.$title; break; } echo_prn(1,"rftrans : $rftrans  rftrans_s : $rftrans_s  fdir  : $fdir"); $ret = rf_mkdir($fdir); if ($ret === false) { echo_prn(1,"mkdir error : $fdir"); return false; } $out = $fdir.$DS.$to; break; case 3: echo_prn(1, "transfer"); echo_prn(1, "from $fr.$ext"); echo_prn(1, "to   (gdrive $rftrans_dir$DS$sdir)$to.$ext"); $ret = gdrive_check(); if ($ret === false) { echo_prn(1, ""); echo_prn(1, "gdrive error"); return false ; } echo_prn(1, ""); $ret = rf_gdrive_upload_file($rftrans_dir, $sdir, $fr, $ext); if ($ret === false) { echo_prn(1, ""); echo_prn(1, "transfer failed"); return false; } if ($cflg == 2) { echo_prn(1, ""); echo_prn(1, "delete"); echo_prn(1, "$fr.$ext"); $ret = unlink("$fr.$ext"); if ($ret === false) { echo_prn(1, "delete failed"); return false; } } return true; break; default: return false; break; } if (($rftrans_codec == 1) && ($prohibit_mp3 == 1)) { echo_prn(1, "現在、mp3 変換機能は利用できません。"); } if (($rftrans_codec == 1) && ($prohibit_mp3 == 0)) { $ext2= "mp3"; $fr2 = "$fr.$ext2"; $art = get_art_img($fr, $ext, $para); if ($art == null) { $opt_art = ""; } else { $opt_art = "-i $art -map_metadata 0 -map 0 -map 1"; } $cmd = "ffmpeg -loglevel quiet -i $fr.$ext $opt_art $rftrans_codec_opt $fr2"; echo_prn(1, "$cmd"); echo_prn(1, " "); time_prn(1, "Start"); echo_prn(1, "Encoding ..."); external_program($cmd); time_prn(1, "End"); fin_unlink($art); $out = "$out.$ext2"; echo_prn(1, " "); echo_prn(1, "move"); echo_prn(1, "from $fr2"); echo_prn(1, "to   $out"); $ret = rf_move($fr2, "$out"); if ($ret === false) { echo_prn(1, "move failed"); return false; } if ($cflg == 2) { fin_unlink("$fr.$ext"); } } else { if ($cflg == 1 || $cflg == 2) { echo_prn(1, "transfer(copy)"); echo_prn(1, "from $fr.$ext"); echo_prn(1, "to   $out.$ext"); $ret = rf_copy("$fr.$ext", "$out.$ext"); if ($ret === false) { echo_prn(1, "copy failed"); return false; } } if ($cflg == 2) { echo_prn(1, ""); echo_prn(1, "del  $fr.$ext"); $ret = unlink("$fr.$ext"); if ($ret === false) { echo_prn(1, "delete failed"); return false; } } } return true; } function rf_rate_disp($st, $en, $reg_dur, $fn) { $now_du = $en - $st; $now_dux = sprintf("%6d", $now_du); if ($now_du < 1) { $now_du = 1; } $now_rt = $reg_dur / $now_du; $now_rtx = sprintf("%01.2f", $now_rt); $now_fs = filesize($fn) * 8 / $now_du / 1024; $now_fsx = sprintf("%6d", $now_fs); echo_prn(1, "Dur : $now_dux sec  Rate : $now_rtx  $now_fsx kbits/sec"); } function rf_rec_info($ex_type, $nw, $ntp_mgn, $para) { $fromtime = $para[0]; $totime = $para[1]; $duration = $para[2]; $pre_mg = rf_pre_mg($ex_type, 0); $post_mg = rf_post_mg($ex_type, 0); $delay = rf_delay_mg($ex_type); $reg_dur = dur_calc($ex_type, $duration, 0); $p_stt = strtotime($fromtime); $p_ent = strtotime($totime); $p_dur = $p_ent - $p_stt; $p_dif = 0; $p_df2 = 0; $e_stt = $nw; $e_ent = $e_stt + $reg_dur; $e_dur = $e_ent - $e_stt; $e_dif = $e_stt - $p_stt; $e_df2 = $e_ent - $p_ent; $r_stt = $e_stt - $delay - $ntp_mgn; $r_ent = $r_stt + $reg_dur; $r_dur = $r_ent - $r_stt; $r_dif = $r_stt - $p_stt; $r_df2 = $r_ent - $p_ent; $mg = $reg_dur - $p_dur; $ep_stt = date("H:i:s", $p_stt); $ep_ent = date("H:i:s", $p_ent); $ep_dur = sprintf("%05d", $p_dur); $ep_dif = sprintf("%3d", $p_dif); $ep_df2 = sprintf("%3d", $p_df2); $ee_stt = date("H:i:s", $e_stt); $ee_ent = date("H:i:s", $e_ent); $ee_dur = sprintf("%05d", $e_dur); $ee_dif = sprintf("%3d", $e_dif); $ee_df2 = sprintf("%3d", $e_df2); $er_stt = date("H:i:s", $r_stt); $er_ent = date("H:i:s", $r_ent); $er_dur = sprintf("%05d", $r_dur); $er_dif = sprintf("%3d", $r_dif); $er_df2 = sprintf("%3d", $r_df2); echo_prn(1, "番組 : $ep_stt($ep_dif) - $ep_ent($ep_df2)  $ep_dur"); echo_prn(1, "実行 : $ee_stt($ee_dif) - $ee_ent($ee_df2)  $ee_dur"); echo_prn(1, "録音 : $er_stt($er_dif) - $er_ent($er_df2)  $er_dur"); echo_prn(1, "配信遅れ : $delay   マージン : $mg ( pre : $pre_mg  post : $post_mg )   ntp : $ntp_mgn"); return; } function rf_rsv_retry($ex_type, $para, $channel) { global $retry_rec; global $radiko_callsign; global $radiru_callsign; global $schradiko_head; global $schradiru_head; global $ex_radiko; global $ex_radiru; global $ex_timefree; global $ex_radiru_vod; $kw = $para[10]; $rty = explode(":", $kw); if (count_73($rty) == 2 && $rty[0] == "retry") { $cnt = $rty[1]; } else { $cnt = 0; } if ($cnt < 0 || $cnt >= $retry_rec) { return 0; } $cnt++; $para[10] = sprintf("retry:%s", $cnt); switch ($ex_type) { case $ex_radiru: $head = $schradiru_head; if ($radiru_callsign == 1) { $para[6] = $channel; } break; case $ex_radiko: $head = $schradiko_head; if ($radiko_callsign == 1) { $para[6] = $channel; } break; default: $head = $schradiko_head; break; } $ret2 = rf_program_rsv(0, $ex_type, $para, $head, 1); if ($ret2 >= 2) { return 0; } return $cnt; } function rf_trans_disp($ex_type) { global $rftrans; global $rftrans_s; global $rftrans_dir; global $rftrans_radiko; global $rftrans_radiru; global $rftrans_timefree; global $rftrans_radiru_vod; global $rftrans_radiru_gogaku; global $rec_extension; global $ex_radiko; global $ex_radiru; global $ex_timefree; global $ex_radiru_vod; global $ex_radiru_gogaku; global $user_process; global $user_process2; global $macos_launch_type; $exeos = get_rfriends_exeos(); $exeos_mac = ""; if ($exeos == "OSX") $exeos_mac = "(".$macos_launch_type.")"; switch ($rftrans) { case 0: $rftransm = "なし"; break; case 1: $rftransm = "iTunes"; break; case 2: switch ($rftrans_s) { case 1: $rftransm = "番組別"; break; case 2: $rftransm = "局別"; break; case 3: $rftransm = "分別無"; break; case 0: default: $rftransm = "局別番組別"; break; } break; case 3: $rftransm = "Google Drive"; break; default: $rftransm = "不明"; break; } switch ($ex_type) { case $ex_radiko: $cflg = $rftrans_radiko; $sdir = "radiko"; break; case $ex_radiru: $cflg = $rftrans_radiru; $sdir = "radiru"; break; case $ex_timefree: $cflg = $rftrans_timefree; $sdir = "timefree"; break; case $ex_radiru_vod: $cflg = $rftrans_radiru_vod; $sdir = "radiru_vod"; break; case $ex_radiru_gogaku: $cflg = $rftrans_radiru_gogaku; $sdir = "radiru_gogaku"; break; default: $cflg = -1; $sdir = "不明"; break; } switch ($cflg) { case 0: $cflgm = "なし"; break; case 1: $cflgm = "複写"; break; case 2: $cflgm = "移動"; break; default: $cflgm = "不明"; break; } echo_prn(1, "OS　　　　　 : " .$exeos.$exeos_mac); echo_prn(1, "種　別　　　 : " .$sdir); echo_prn(1, "転　送　　　 : " .$rftransm); echo_prn(1, "転送先　　　 : " .$rftrans_dir); echo_prn(1, "転送モード　　 : " .$cflgm); echo_prn(1, "ユーザプロセス   : ".$user_process); echo_prn(1, "ユーザプロセス2  : ".$user_process2); } function rec_file_check_s($cmode,$srcfile, $dstfile) { global $rftrans; global $rftrans_s; if (!file_exists($srcfile)) { echo_prn(1, "$srcfile not exists"); return false; } if (!file_exists($dstfile)) { echo_prn(1, "target not exists"); return false; } if (rf_compare_filesize($srcfile,$dstfile) === false) { echo_prn(1, "exists but size error"); return false; } echo_prn(1, "deleted $dstfile"); fin_unlink($dstfile); if ($rftrans != 2) return true; $pdir = dirname($dstfile); rf_rmdir($pdir); return true; } function rec_file_check($ex_type, $recfile, $ext, $channel, $title) { global $timefree_radiko_del; global $radiru_vod_radiru_del; global $radiru_gogaku_radiru_del; global $ex_radiko; global $ex_radiru; global $ex_timefree; global $ex_radiru_vod; global $ex_radiru_gogaku; global $usrdir; global $DS; global $rftrans; global $rftrans_s; global $rftrans_dir; switch($ex_type) { case $ex_timefree: $cmode = $timefree_radiko_del; if ($cmode == 2) $cmode = 1; if ($cmode == 4) $cmode = 3; $mes = "timefree_radiko_del"; $sdir = "timefree"; $ddir = "radiko"; $ex_type_p = $ex_radiko; break; case $ex_radiru_vod: $cmode = $radiru_vod_radiru_del; $mes = "radiru_vod_radiru_del"; $sdir = "radiru_vod"; $ddir = "radiru"; $ex_type_p = $ex_radiru; break; default: $cmode = 0; return false; break; } if ($cmode == 0) { return false; } $delty = ""; if ($cmode == 0) $delty = "(無効)"; if ($cmode == 1) $delty = "(ファイル名:削除)"; if ($cmode == 2) $delty = "(番組名:削除)"; if ($cmode == 3) $delty = "(ファイル名:移動)"; if ($cmode == 4) $delty = "(番組名:移動)"; echo_prn(1, ""); echo_prn(1, "$mes : $cmode $delty"); $sdir1 = $usrdir.$sdir.$DS; $srcfile = $sdir1."$recfile.$ext"; $ddir1 = $usrdir.$ddir.$DS; $dstfile = $ddir1."$recfile.$ext"; $ret1 = false; switch($cmode) { case 1: $ret1 = rf_compare_delete_file(0,$srcfile,$ddir1); break; case 2: $ret1 = rf_compare_delete_program(0,$srcfile,$sdir1,$ddir1,$ex_type_p); break; case 3: $ret1 = rf_compare_delete_file(1,$srcfile,$ddir1); break; case 4: $ret1 = rf_compare_delete_program(1,$srcfile,$sdir1,$ddir1,$ex_type_p); break; default: break; } if ($ret1 === true) return true; if ($rftrans == 2) { switch ($rftrans_s) { case 1: $sdir2 = $rftrans_dir.$sdir.$DS.$channel.$DS.$title.$DS; $srcfile2 = $sdir2."$recfile.$ext"; $ddir2 = $rftrans_dir.$ddir.$DS.$channel."_".$title.$DS; $dstfile2 = $ddir2."$recfile.$ext"; break; case 2: $sdir2 = $rftrans_dir.$sdir.$DS.$channel.$DS; $srcfile2 = $sdir2."$recfile.$ext"; $ddir2 = $rftrans_dir.$ddir.$DS.$channel.$DS; $dstfile2 = $ddir2."$recfile.$ext"; break; case 3: $sdir2 = $rftrans_dir; $srcfile2 = $sdir2."$recfile.$ext"; $ddir2 = $rftrans_dir; $dstfile2 = $ddir2."$recfile.$ext"; break; case 0: default: $sdir2 = $rftrans_dir.$sdir.$DS.$channel.$DS.$title.$DS; $srcfile2 = $sdir2."$recfile.$ext"; $ddir2 = $rftrans_dir.$ddir.$DS.$channel.$DS.$title.$DS; $dstfile2 = $ddir2."$recfile.$ext"; break; } if (!file_exists($srcfile)) { $srcfile = $srcfile2; } $ret2 = false; switch($cmode) { case 1: $ret2 = rf_compare_delete_file(0,$srcfile,$ddir2); break; case 2: $ret2 = rf_compare_delete_program(0,$srcfile,$sdir2,$ddir2,$ex_type_p); break; case 3: $ret2 = rf_compare_delete_file(1,$srcfile,$ddir2); break; case 4: $ret2 = rf_compare_delete_program(1,$srcfile,$sdir2,$ddir2,$ex_type_p); break; default: break; } if ($ret2 === true) return true; } return false; } function rftrans_job_1($ex_type, $fr, $ext, $to, $para,$para2) { global $cfgdir; global $user_process2; global $rftrans; global $rftrans_s; global $ex_podcast; if ($rftrans != 0) { echo_prn(1, "process mode : 1"); $ret = rftrans_ex($ex_type, $fr, $ext, $to, $para2); } if (delivery_sw() === true) { echo_prn(1, "process mode : 2"); $recdir = get_recdir($ex_type); $ret = delivery_rec_program($ex_type, $para, $recdir, $to, $ext); } if (($user_process2 == 1) && ($ex_type != $ex_podcast)) { echo_prn(1, "process mode : 3"); $up_mes1 = date("Y/m/d H:i:s")." user_process2 start-up"; echo_prn(1, ""); echo_prn(1, $up_mes1); $ex = "user_process2"; rfgw_batsh_sub($cfgdir, $ex, "\""."$fr.$ext"."\"", 1, 1); } return true; } function rftrans_job_0($ex_type, $fr, $ext, $to, $para,$para2) { global $cfgdir; global $user_process2; global $rftrans; global $rftrans_s; global $ex_podcast; $prmode = 0; $prname = "off"; if ($rftrans != 0) { $prmode = 1; $prname = "transfer"; } else if (delivery_sw() === true) { $prmode = 2; $prname = "delivery"; } else if (($user_process2 == 1) && ($ex_type != $ex_podcast)) { $prmode = 3; $prname = "user_process_2"; } echo_prn(1, "process mode : $prname"); if ($prmode == 0) return true; switch($prmode) { case 1: $ret = rftrans_ex($ex_type, $fr, $ext, $to, $para2); break; case 2: $recdir = get_recdir($ex_type); $ret = delivery_rec_program($ex_type, $para, $recdir, $to, $ext); break; case 3: $up_mes1 = date("Y/m/d H:i:s")." user_process2 start-up"; echo_prn(1, ""); echo_prn(1, $up_mes1); $ex = "user_process2"; rfgw_batsh_sub($cfgdir, $ex, "\""."$fr.$ext"."\"", 1, 1); break; default: break; } return true; } function rftrans_job($ex_type, $fr, $ext, $to, $para,$para2) { global $rftrans_job_mode; echo_prn(1, "rftrans job mode : $rftrans_job_mode"); switch ($rftrans_job_mode) { case 1: rftrans_job_1($ex_type, $fr, $ext, $to, $para,$para2); break; case 0: default: rftrans_job_0($ex_type, $fr, $ext, $to, $para,$para2); break; } return true; } function rfriends_downloader($ex_type, $fnm, $reg_dur, $para, $title_flag, $ffmpeg_ver) { global $tf_footer; global $radiko_callsign; global $radiru_callsign; global $streamurlhls; global $tmpdir; global $retry_rec; global $stream_url; global $msg_level; global $ffmpeg_loglevel; global $ffmpeg_loglevel_timefree; global $add_img; global $dont_sleep; global $dontsleep_timer_tf; global $schradiko_head; global $schradiru_head; global $rftrans; global $rec_extension; global $dwn_extension; global $download_aac; global $rec_sleep_program; global $area_code; global $nowarea; global $home_area_code; global $radiko_auth_mode; global $auth_token_dat; global $usrdir; global $tmpdir; global $space_min; global $tmp_space_min; global $ex_radiko_delay; global $ex_radiko_pre_margin; global $ex_radiko_post_margin; global $premium_delay; global $premium_pre_margin; global $premium_post_margin; global $radiko_delay; global $radiko_pre_margin; global $radiko_post_margin; global $ex_radiko_genre; global $premium_genre; global $radiko_genre; global $premium_area; global $user_auth; global $ex_radiko; global $ex_radiru; global $ex_timefree; global $ex_radiru_vod; global $rec_normal_end; global $rec_normal_end_plus; global $rec_already_exist; global $rec_not_deliver; global $rec_abnormal_end; global $premium; global $cookiefile; global $radiko_nhk; global $wget_opt_ext; global $wget_opt_https_proxy; global $wget_opt_proxy_user; global $wget_opt_proxy_pass; global $radiko_auth_mode3_dat; global $keyword; global $cfgdir; global $user_process2; global $loghead_bad; global $loghead_cancel; global $loghead_short; global $loghead_delay; global $loghead_abnormal; global $loghead_skip; global $loghead_error; $fromtime = $para[0]; $totime = $para[1]; $duration = $para[2]; $failed_record = $para[3]; $in_ng = $para[4]+0; $out_ng = $para[5]+0; $channel = $para[6]; $title = $para[7]; $kw = $para[10]; $prefno = $para[13]; $area = $para[14]; $genre = $para[16]; $genrec = $para[17]; if ($genre == ";") $genre = ""; if ($genrec == ";") $genrec = ""; $secmes = "rfriends downloader Ver.1.8.0"; if ($title_flag == 1) { echo_prn(1, ""); stat_prn(1,"vmstat"); echo_prn(1, ""); rf_disp_section($secmes, "+"); rf_trans_disp($ex_type); } $ret = clear_log_hour(4, $tmpdir, "{*.aac,*.m4a,*.mp3}", 1, 0, 0); $recfiletmp = $tmpdir.$fnm; $ext = $rec_extension; $dwn = $dwn_extension; $recdir = get_recdir($ex_type); $ng = set_ng($failed_record, $in_ng, $out_ng); $ok = set_ok($failed_record, $in_ng, $out_ng); $output = fnam_edit($ex_type,$para); if ($download_aac == 1) { $dwn = "aac"; } if ($ex_type == $ex_timefree || $ex_type == $ex_radiru_vod) { $dwn = $ext; } if ($kw == "manual") { $output = $output."_m"; } file_put_contents("$recfiletmp.ttl", $output); if ($ex_type != $ex_timefree && $ex_type != $ex_radiru_vod) { $nw = time(); $sec = date("s", $nw); if ($sec > 10) { } $ntp_mgn = disp_ntp(); } $gen = rf_set_genre($ex_type,$genre,$genrec); if (rf_check_double_rec($ex_type, $output, $ext, $channel, $title, 0, 0) === true) { rf_title_disp(1, "", "", $output,$gen,0); echo_prn(1, ""); echo_prn(1, "この番組はすでに録音済みです。"); rec_file_check($ex_type,$output, $ext, $channel, $title); rf_touch($tmpdir."$fnm.skp"); return $rec_already_exist; } rf_title_disp(1, "", "", $output,$gen,1); echo_prn(1,str_repeat("-",80)); $ret = rf_capacity_check($fromtime,$totime); if ($ret === false) { echo_prn(1, "十分な空き容量がありません。"); return $rec_abnormal_end; } echo_prn(1,str_repeat("-",80)); $bad = ""; $retry_count = 0; $result_flag = 0; if ($ex_type == $ex_timefree) { $nw = time(); $ret = timefree_check($nw, $para, 1); if ($ret != 0) { return $ret; } } if ($ex_type == $ex_radiko || $ex_type == 3 || $ex_type == $ex_timefree) { start_prn(1,"get authtoken start"); echo_prn(1, ""); if ($wget_opt_https_proxy != "") { time_prn(1, "wget_proxy auth start"); echo_prn(1, "wget_proxy : $wget_opt_https_proxy"); if ($wget_opt_proxy_user != "") { echo_prn(1, "wget_user  : $wget_opt_proxy_user"); echo_prn(1, "wget_pass  : *****"); } time_prn(1, "wget_proxy auth end"); } $mode = rf_premium_mode($area,$channel); echo_prn(1, "認証モード:$radiko_auth_mode (プレミアム:$mode  録音エリア:$area)"); if ($radiko_auth_mode == 3) { if (file_exists($radiko_auth_mode3_dat)) { $gps = @file_get_contents($radiko_auth_mode3_dat); if ($gps !== false) { $gps = trim($gps); $gps_date = date("Y/m/d H:i:s",filemtime($radiko_auth_mode3_dat)); echo_prn(1,"$radiko_auth_mode3_dat : $gps_date"); echo_prn(1,"GPS : $gps"); } } } $mode2 = $mode; if ($premium == 2) $mode2 = 0; echo_prn(1, "エリアフリー:$mode2 [エリア:$area  CH:$channel] [エリアコード:$area_code] [ホーム:$home_area_code]"); $authtoken = rfriends_auth_radiko($mode,$area,0); if (is_null($authtoken)) { echo_prn(1, "authtoken が取得できませんでした。"); start_prn(1,"get authtoken end"); echo_prn(1, ""); return $rec_abnormal_end; } start_prn(1,"get authtoken end"); echo_prn(1, ""); } switch ($ex_type) { case $ex_radiko: case 3: if ($radiko_callsign == 1) { $ch_cs = get_radiko_callsign($channel); echo_prn(1, "call sign : $para[6] -> $ch_cs"); $para[6] = $ch_cs; $output = fnam_edit($ex_type,$para); if ($kw == "manual") { $output = $output."_m"; } } switch ($mode2) { case 1: $dmode = "P"; $ex_radiko_genre = $premium_genre; $ex_radiko_delay = $premium_delay; $ex_radiko_pre_margin = $premium_pre_margin; $ex_radiko_post_margin = $premium_post_margin; break; case 0: $dmode = "N"; $ex_radiko_genre = $radiko_genre; $ex_radiko_delay = $radiko_delay; $ex_radiko_pre_margin = $radiko_pre_margin; $ex_radiko_post_margin = $radiko_post_margin; break; default: echo_prn(1, "mode error [$area $channel] [area_code : $area_code] [home : $home_area_code]"); return $rec_abnormal_end; break; } $hlsurl = get_radiko_stream_url($channel, $recfiletmp, $mode2); if ($hlsurl == "") { echo_prn(1, "stream_url not found (not delivered)"); return $rec_not_deliver; } $tout = $reg_dur + 120; $ffopt = rfgw_ffmpeg_opt($ex_radiko); $opt = sprintf($ffopt, $hlsurl, $tout, $reg_dur, $authtoken); $expgm = "ffmpeg -loglevel $ffmpeg_loglevel"; break; case $ex_timefree: if ($radiko_callsign == 1) { $ch_cs = get_radiko_callsign($channel); echo_prn(1, "call sign : $para[6] -> $ch_cs"); $para[6] = $ch_cs; $output = fnam_edit($ex_type,$para); if ($kw == "manual") { $output = $output."_m"; } } $hlsurl = get_timefree_stream_url($channel, $fromtime, $totime, $recfiletmp, $authtoken,0); if ($hlsurl == "") { echo_prn(1, "stream_url not found (not delivered or area unmatch)"); return $rec_not_deliver; } echo_prn(1, $hlsurl); $tout = calc_timefree_timeout($reg_dur); $ffopt = rfgw_ffmpeg_opt($ex_timefree); $opt = sprintf($ffopt, $hlsurl, $tout, $reg_dur, $authtoken); $expgm = "ffmpeg -loglevel $ffmpeg_loglevel_timefree"; break; case $ex_radiru: case 4: case 6: $ok = ""; if ($radiru_callsign == 1) { $ch_cs = get_radiru_callsign_new($channel); echo_prn(1, "call sign : $para[6] -> $ch_cs"); $para[6] = $ch_cs; $output = fnam_edit($ex_type,$para); if ($kw == "manual") { $output = $output."_m"; } } $hlsurl = radiru_hls_url($channel); if ($hlsurl == null) { echo_prn(1, "error $channel"); return $rec_abnormal_end; } $expgm = "ffmpeg -loglevel $ffmpeg_loglevel"; $tout = $reg_dur + 120; $ffopt = rfgw_ffmpeg_opt($ex_radiru); $opt = sprintf($ffopt, $hlsurl, $tout, $reg_dur); break; } $rec_sleep_program = 0; if ($rec_sleep_program != 1) { echo_prn(1, ""); if ($ex_type == $ex_timefree || $ex_type == $ex_radiru_vod) { time_prn(1, "dontsleep start"); rfgw_start_dontsleep($ex_type, $fnm, $reg_dur, $dontsleep_timer_tf, 0); } else { $ret = rf_rec_sleep($ex_type, $fnm, $ntp_mgn); } } $now_st0 = time(); if ($ex_type != $ex_timefree && $ex_type != $ex_radiru_vod) { $recstime = recstime_calc($ex_type, $fromtime, 0) + $ntp_mgn; $diff_program = $now_st0 - $recstime; if (abs($diff_program) > 10) { $recstime_d = date("Y/m/d H:i:s", $recstime); echo_prn(1, ""); time_prn(1, "##### 録音開始時間 [$recstime_d] を過ぎています。 #####"); $bad = $loghead_delay; $result_flag = 1; if (abs($diff_program) > 300) { return $rec_abnormal_end; } } echo_prn(1, ""); rf_rec_info($ex_type, $now_st0, $ntp_mgn, $para); } if ($msg_level == 2) { $expgm = "ffmpeg -loglevel quiet"; } $exec_cmd = "$expgm $opt $recfiletmp.$dwn"; echo_prn(1, " "); echo_prn(1, $ffmpeg_ver); echo_prn(1, $exec_cmd); echo_prn(1, str_repeat(".", 40)); $logmes = "ffmpeg $output.$ext"; rf_error_log_ffmpeg("Start ",$logmes); echo_prn(1, "Downloading ..."); $now_st = time(); fin_unlink("$recfiletmp.end"); rf_touch("$recfiletmp.run"); $ret = external_program($exec_cmd); $now_en = time(); rf_error_log_ffmpeg("End(".$ret.") ",$logmes); rf_touch("$recfiletmp.end"); fin_unlink("$recfiletmp.run"); if ($ret != 0) { echo_prn(1, ""); stat_prn(1,"vmstat"); echo_prn(1, ""); if (file_exists("$recfiletmp.can")) { $result_flag = 3; $mes = "##### 要求により中止しました。 #####"; rf_error_message(-1, $ex_type, $mes, "$output.$dwn", "$fnm.$dwn"); return $rec_abnormal_end; } else { $result_flag = 4; $mes = "##### 異常終了しました。 #####"; rf_error_message(-1, $ex_type, $mes, "$output.$dwn", "$fnm.$dwn"); if (($ex_type == $ex_radiko) || ($ex_type == $ex_radiru)) { $retry_count = rf_rsv_retry($ex_type, $para, $channel); if ($retry_count > 0) { echo_prn(1, "再予約しました。($retry_count 回目)"); rf_error_log("再予約しました。($retry_count 回目)"); } } return $rec_abnormal_end; } } if ($dwn != $ext) { echo_prn(1, ""); time_prn(1, "$dwn -> $ext start"); $exec_cmd = "ffmpeg -loglevel quiet -i $recfiletmp.$dwn -codec:a copy $recfiletmp.$ext"; echo_prn(1, "$exec_cmd"); $ret = external_program($exec_cmd); if ($ret != 0) { $mes = "##### コンバートに失敗しました。 #####"; rf_error_message(-1, $ex_type, $mes, "$output.$dwn", "$fnm.$dwn"); fin_unlink("$recfiletmp.$dwn"); return $rec_abnormal_end; } } if (!file_exists("$recfiletmp.$ext")) { return $rec_abnormal_end; } rf_rate_disp($now_st, $now_en, $reg_dur, "$recfiletmp.$ext"); $ans = get_mediainfo("$recfiletmp.$ext", "duration", "xml"); if ($ans == null) { $bad = $loghead_bad; $mes = "##### データ不良のため削除します。 #####"; fin_unlink("$recfiletmp.$ext"); rf_error_message(-1, $ex_type, $mes, "$output.$ext", "$fnm.$ext"); return $rec_abnormal_end; } $diff_dur = $ans - $reg_dur; $dur_hms = date("H:i:s", $reg_dur + strtotime("1970/01/01")); $ans_hms = date("H:i:s", $ans + strtotime("1970/01/01")); echo_prn(1, ""); echo_prn(1, "duration : $reg_dur ($dur_hms) -> $ans ($ans_hms)"); echo_prn(1, "diff     : $diff_dur sec(s)"); if ($diff_dur < -20) { $mes = "##### 早期終了の可能性があります。 #####"; rf_error_log("$output.$ext"); rf_error_log($mes); $bad = $loghead_short; $result_flag = 2; } $rf_head = $bad.$ok; $rf_foot = ""; if ($ex_type == $ex_timefree) { $rf_head = $bad.$ng; $rf_foot = $tf_footer; } if ($ex_type == $ex_radiru_vod) { $rf_head = $bad.$ng; $rf_foot = $vod_footer; } $recf = $rf_head.$output.$rf_foot; $recfile = $recdir.$recf; $ret = rf_space_check("$recfiletmp.$ext"); if ($ret === true) { set_tag_img($ex_type, $recfiletmp, $ext, $para, $para, $rf_head, $rf_foot); } else { echo_prn(1, ""); echo_prn(1, "十分な空き容量がありません。(addtag)"); rf_error_log("十分な空き容量がありません。(addtag)"); rf_error_log("$recfiletmp.$ext"); } echo_prn(1, str_repeat("-", 40)); echo_prn(1, "rfriends-info-start"); disp_mediainfo(1, "$recfiletmp.$ext", "$recfile.$ext"); $dirn = dirname("$recfile.$ext"); if (!is_dir($dirn)) { echo_prn(1, "make dir : $dirn"); mkdir($dirn); } $ret = rf_movefile("$recfiletmp.$ext","$recfile.$ext",1,$ex_type,$totime); if ($ret === false) { $mes = "##### ファイルが移動できませんでした。 #####"; rf_error_message(-1, $ex_type, $mes, "$output.$ext", "$fnm.$ext"); $ret = unlink("$recfiletmp.$ext"); if ($ret === false) { rf_error_log("failed delete : $recfiletmp.$ext"); } echo_prn(1, ""); echo_prn(1, "rfriends-info-end"); return $rec_abnormal_end; } if ($bad != "") { echo_prn(1, ""); echo_prn(1, "rfriends-info-end"); return $rec_abnormal_end; } $ret = rec_file_check($ex_type,$output, $ext, $channel, $title); $ret_cond = $rec_normal_end; if ($ret === true) $ret_cond = $rec_normal_end_plus; $fr = "$recfile"; $to = "$recf"; echo_prn(1, ""); echo_prn(1, "rfriends-file-name : $fr.$ext"); $ret = rftrans_job($ex_type, $fr, $ext, $to, $para,$para); echo_prn(1, ""); echo_prn(1, "rfriends-info-end"); return $ret_cond; } 